Title: Основы асимметричной криптографии

<p><b>Асимметричная криптография</b> - принципиально новый раздел криптографии, занимающийся криптоалгоритмами с открытым ключом, то есть алгоритмами электронной подписи, асимметричного шифрования и получения общего секрета.</p>

<h2>Суть</h2>

<p>До 1976 года перед человечеством, уже имевшем сильные шифры типа Люцифера, стояла серьёзная проблема распространения ключей к таким алгоритмам. Чтобы начать шифроваться, двум сторонам было необходимо договориться об используемом ключе по другому защищённому от прослушивания каналу, например, при личной встрече. Это, в принципе, логично, но обходные пути всё же были найдены.</p>

<p>Поначалу умными людьми предлагались различные костыли. Например, в случае радиообмена одна сторона могла зашумлять эфир случайным сигналом во время передачи ключа другой стороной, а затем вычитать этот шум из полученной информации и вычислять ключ. Сторонний наблюдатель не мог разобрать, какой из источников испускает шум, а какой - секретные данные, и отделить их друг от друга.</p>

<p>Но в 1976 году Уитфилд Диффи и Мартин Хеллман таки разразились нормальным универсальным решением, которое позволяло начать секретное общение без предварительного знания общего ключа. Единственное условие - канал хоть и мог прослушиваться, но не мог модифицироваться. Потом, как и бывает со всяким прорывным изобретением, появилось множество устроенных совершенно по другому принципу альтернатив.</p>

<h2>Получение общего ключа</h2>

<p>Среди асимметричных алгоритмов встречаются алгоритмы шифрования и электронной подписи, однако оба этих действия можно выполнить и в симметричном виде, если участвуют две стороны, имеющие общий секретный ключ. Его можно использовать для шифрования обычным шифром типа AES или для создания имитовставки HMAC.</p>

<h3><a href="https://en.wikipedia.org/wiki/Merkle_puzzle">Головоломка Меркла</a></h3>

<p>До изобретения первого в мире асимметричного алгоритма, уже были попытки собрать что-то подобное на основе симметричных схем. Так, американский штудент - Ральф Меркл (который стал крутым криптографом и изобрёл много всякого, например, дерево Меркла, используемое в Биткоине) в своём курсаче описал очень простую схему:</p>

<ol>
<li>Я создаю 2<sup>40</sup> крупных случайных чисел и зашифровываю их все слабыми 40-битными ключами, добавив немного избыточности, например, приписав к числам несколько нулей справа перед зашифровыванием. В результате получается несколько терабайт отборного шума, которые я отсылаю тебе по электронной почте.</li>
<li>Ты совершенно случайным образом выбираешь оттуда любое зашифрованное число и брутфорсишь его целый день на своём Радеоне. Это даётся довольно легко, потому что ключ-то слабый.</li>
<li>Всё - теперь ты расшифровал это число и будешь использовать его как ключ для общения со мной, главное, не забудь намекнуть мне, какое число ты выбрал, например, прислав его хеш.</li>
</ol>

<p>Суть в том, что я могу понять, какое число ты выбрал, потому что у меня все они есть и я знаю их хеши. И ты тоже по очевидным причинам знаешь, какое число выбрал. Но вот злоумышленник не знает, и чтобы узнать, ему придётся в худшем случае расшифровать <i>все</i> числа и сверить их хеши. Одно число рашифровать несложно - это потребует 2<sup>40</sup> операций, но чисел самих 2<sup>40</sup> штук, поэтому хакер влетел перебирать 2<sup>80</sup> ключей. Для сравнения, лучший результат, полученный Bitcoin, составляет 79 бит.</p>

<h3><a href="https://ru.wikipedia.org/wiki/Протокол_Диффи-Хеллмана">Алгоритм Диффи-Хеллмана</a></h3>

<p>Первый чистокровный асимметричный алгоритм был изобретён двумя американскими умничками в 1976 году. Честолюбивое АНБ потом заявило, что знало о такой возможности ещё в 1966 году, но им никто не поверил.</p>

<p>В основе алгоритма лежит коммутативная необратимая операция. В качестве этой операции может выступать либо возведение в степень по модулю простого числа, или умножение числа на точку на эллиптической кривой в конечном поле. Это очень сложная математика, но самый простой случай - со степенями - понять легко.</p>

<p>Как известно, число можно возводить в несколько степеней в разном порядке, и результат от этого не изменится: (a<sup>b</sup>)<sup>c</sup> = (a<sup>c</sup>)<sup>b</sup>. Возведение в степень легко обращается - зная A = a<sup>x</sup>, я могу вычислить x = log<sub>a</sub>A. Но оно становится необратимым, если выполнять его по модулю простого числа, то есть после возведения в степень делить результат на это число и брать остаток от деления. Например: 15<sup>17</sup> = 98526125335693359375, остаток от деления этого числа на 29 есть 18. Это записывается как 18 = 15<sup>17</sup> mod 29. Если представить, что на месте этих 15, 17 и 29 стоят огромные числа, то зная 18 = 15<sup>x</sup> mod 29, ты никак не сможешь вычислить x.</p>

<p>Примечательно, что свойства степеней сохраняются и при оперировании по модулю, то есть если сначала вычислить a<sup>b</sup> mod p, а потом возвести в степень c по тому же модулю, то результат будет тот же, как если вычислять это в другом порядке (a<sup>c</sup>)<sup>b</sup> mod p. Ну а дальше не надо быть супергением, чтобы сложить из этого криптоалгоритм (mod опущен для чистоты, но он подразумевается):</p>

<ol>
<li>Выбираем основание степени a - это несекретное число, его можно опубликовать или даже вшить в программу.</li>
<li>Я генерирую своё огромное число b и считаю B = a<sup>b</sup>. Большую B я публикую, тогда как малая b - мой секретный ключ.</li>
<li>Ты генерируешь своё огромное число c и считаещь C = a<sup>c</sup>. Большую С ты публикуешь, тогда как малая c - твой секретный ключ.</li>
<li>Я беру твоё C и получаю из него наш общий секретный ключ K = C<sup>b</sup>.</li>
<li>Ты берёшь моё B и получаешь из него наш общий секретный ключ K = B<sup>c</sup>.</li>
</ol>

<p>Теперь у нас есть общий ключ K, о котором никто, кроме нас, не знает. Мой K = твоему, потому что я сделал K = (a<sup>c</sup>)<sup>b</sup>, а ты сделал K = (a<sup>b</sup>)<sup>c</sup>. И мы сделали это, не зная секретных чисел друг друга, подставив в эти выражения полученные от другой стороны a<sup>b</sup> = B и a<sup>c</sup> = C. Всекаешь? То-то же. А злоумышленник - нет, поскольку для получения K необходимо знать хотя бы одно из секретных чисел, но вычислить их из B или C нельзя, ведь после каждой операции берётся остаток от деления.</p>

<h4>Защищённость</h4>

<p>Стоит заметить, что обращение возведения в степень по модулю или скалярного умножения числа на точку на эллиптической кривой в конечном поле - дискретное логарифмирование - <i>потенциально</i> необратимая операция. Многие асимметричные алгоритмы опираются на веру в неравенство классов сложности <a href="https://ru.wikipedia.org/wiki/Равенство_классов_P_и_NP">NP и P</a>, которая пока не доказана. Это означает, что в один прекрасный день кто-нибудь может взломать такие алгоритмы, причём все разом, решив любую NP-полную задачу, которая сводится ко всем задачам из этого класса. И этот прекрасный день обязательно настанет, когда появятся мощные <a href="https://ru.wikipedia.org/wiki/Алгоритм_Шора">квантовые компьютеры</a>.
<p>Головоломка Меркла и несколько других не таких как все асимметричных алгоритмов такой проблеме не подвержены, но их никто не использует либо ввиду непрактичности, либо из-за малой изученности.</p>

<h4>Альтернативное объяснение</h4>

<p><a href="https://www.youtube.com/watch?v=YEBfamv-_do">Тынц</a>.</p>

<h2>Электронная подпись</h2>

<p>Кроме алгоритмов получения общего секрета, есть специализированные алгоритмы, предназначенные для подписи или шифрования, а то и для обеих целей сразу.</p>

<p>Электронная подпись - это такой набор байтов, который связан с каким-то сообщением и может быть сгенерирован только владельцем закрытого ключа, а проверен - любым, у кого есть ключ открытый. Подписанный документ нельзя модифицировать, не повредив электронную подпись, поэтому она используется для авторизации. В то же время, однажды подписав документ, не получится отречься от подписи в будущем - можно подписывать контракты.</p>

<p>Как правило, подписывают не само сообщение, а его хеш, потому что длина хеша достаточно мала и всегда фиксирована, в отличие от длины сообщения.</p>

<h3><a href="https://research.microsoft.com/en-us/um/people/lamport/pubs/dig-sig.pdf">Схема Лэмпорта</a></h3>

<p>Схема Лэмпорта - самый естественный алгоритм ЭЦП, но у него есть недостаток - им можно подписать только одно сообщение.</p>

<p>Если я задумаю две случайных строки и опубликую их хеши, то это можно считать моим открытым ключом. Этим ключом я могу подписать один бит информации: если он равен 0, то я публикую первую строку, иначе - вторую. Кто угодно может проверить хеш опубликованной строки и убедиться, что она соответствтует моего открытому ключу, то есть подпись сделана мной.</p>

<p>Логичное продолжение затеи - публиковать больше одной пары строк, чтобы можно было подписать много бит сразу. Ральф Меркл произвёл ещё кучу улучшений этой идеи, доведя её до очень даже практичной конфетки, в частности придумал дерево Меркла, позволяющее сделать больше одной подписи одним ключом.</p>

<h2>Шифрование</h2>

<p>Есть также специальные алгоритмы, предназначенные для шифрования. Открытый ключ не является секретом и кто угодно может им воспользоваться и зашифровать сообщение, но только владелец соответствующего закрытого ключа сможет сообщение расшифровать.</p>

<h3><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%A0%D0%B0%D0%B1%D0%B8%D0%BD%D0%B0">Схема Рабина</a></h3>

<p>Широко известный в узких кругах Майкл Рабин (тот самый, который придумал тест на простоту, используемый для генерации больших простых чисел) создал простую схему асимметричного шифрования: c = m<sup>2</sup> mod n. Шифруемый текст превращается в число, возводится в квадрат, и итоговый результат есть остаток от деления квадрата на открытый ключ n.</p>

<p>Чрезвычайно важным свойством такой схемы является её доказанность - достоверно известно, что нахождение корня по модулю не менее сложно, чем разложение закрытого ключа на множители. Тот же RSA (подобный алгоритм) может быть быть взломан даже без решения NP-полной задачи, которой является разложение на множители (и такой взлом был <a href="https://crypto.stanford.edu/~dabo/papers/no_rsa_red.pdf">продемонстирован</a> для малых значений шифрующих показателей степени).</p>

<p>Для расшифровывания необходимо знать простые множители (p и q) открытого ключа n, они и являются закрытым ключом и должны быть тоже достаточно большими. Ради упрощения расшифровывания с помощью китайской теоремы об остатках рекомендуется выбирать p и q так, чтобы им не хватало 1 до делимости на 4. Сама процедура выглядит несколько мозгоёбски, поэтому описывать здесь её нет смысла, надо только заметить, что в результате получится 4 разных сообщения, одно из которых верно. Поэтому необходимо добавлять в сообщение перед зашифровыванием немного избыточности, чтоб получатель мог определить, какая версия правильная.</p>

<h2>Ещё</h2>

<p>В статье описаны самые простые алгоритмы для общего понимания, благо такие существуют. Смысла описывать здесь все алгоритмы и их технические подробности нет - для этого есть книги и документация.</p>

<p>Асимметричных шифров существует великое множество, и периодически появляются новые с разными интересными свойствами, но в основном применяются RSA, Диффи-Хеллман (в HTTPS) и производные Эль-Гамаля и их эллиптические версии (DSA, ECDSA, патриотичный велосипед ГОСТ Р 34.10-94. Их легко осилить, поняв Диффи-Хеллмана). Есть чисто академические варианты типа схем Рабина, Шнора, GHR - более полный список в <a href="https://en.wikipedia.org/wiki/Template:Cryptography_public-key">английской Википедии</a>.</p>

<h2>Человек посередине</h2>

<p>Все без единого исключения асимметричные алгоритмы подвержены атаке "человек посередине", и с этим ничего нельзя сделать.</p>

<p>Как уже было сказано во введении, во время общения по незащищённому каналу, асимметричные шифры гарантируют, что подслушивающий злоумышленник не сможет узнать, о чём идёт разговор. Но если он способен не только слушать, но и вмешиваться, модифицируя передаваемую информацию, то он запросто может незаметно вломиться в разговор.</p>

<p>Идея заключается в том, что в момент обмена открытыми ключами, злоумышленник пресекает этот обмен и отдаёт сторонам свои собственные ключи. Стороны не могут это задетектить, поэтому в дальнейшем пользуются этими поддельными ключами, общаясь на самом деле с атакующим, который просто перешифровывает и пересылает все сообщения от одного собеседника другому, чтобы не палиться.</p>

<p>Стоит заметить, что с этической точки зрения проблема отсутствует вовсе. Если два человека начинают общение как анонимы, то можно полноправно считать, что каждый из них общается со вмешавшимся посередине мудаком, а то, откуда он берёт ответы, роли не играет - он ведь тоже анонимен. Это как играть в шахматы по интернету, передавая все ходы компьютерной игре.</p>

<p>Если же одна из сторон не является анонимной, то проблема связи реальной личности с ключами совершенно естественна, и без помощи из невиртуальной реальности тут не обойтись. Поэтому для установления доверенного HTTPS-соединения необходимы удостоверяющие центры, которые, будучи обязанными юридически, своим авторитетным словом скажут, что такой-то ключ и правда принадлежит такому-то банку.</p>

<p>Если требуется установить связь между ключом и какой-то человекочитаемой строкой (например, доменным именем), то тут тоже нельзя обойтись без вмешательства извне, поскольку требуется понятие частной собственности на эту строку. Но самые современные передовые технологии позволяют решить это без централизованного удостоверяющего агента - с помощью децентрализованного.</p>

<p><i>Источник: hiddengate.i2p</i></p>
